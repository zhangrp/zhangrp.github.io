<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>MyBatis · 博客</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="Mybatis是一个半ORM（Object Relational Mapping对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="MyBatis · 博客"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="Mybatis是一个半ORM（Object Relational Mapping对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="博客 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="博客 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="博客"/><h2 class="headerTitleWithLogo">博客</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/directory" target="_self">Docs</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">MyBatis</h1></header><article><div><span><p>Mybatis是一个半ORM（Object Relational Mapping对象关系映射）框架，它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态sql，可以严格控制sql执行性能，灵活度高。</p>
<p>MyBatis可以使用XML或注解来配置和映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。</p>
<p>通过xml文件或注解的方式将要执行的各种statement配置起来，并通过java对象和statement中sql的动态参数进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射为java对象并返回。（从执行sql到返回result的过程）。</p>
<h2><a class="anchor" aria-hidden="true" id="和的区别是什么"></a><a href="#和的区别是什么" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a><code>#{}</code>和<code>${}</code>的区别是什么</h2>
<p><code>#{}</code>是预编译处理，<code>${}</code>是字符串替换。</p>
<p>Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为<code>?</code>号，调用PreparedStatement的set方法来赋值；在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值。</p>
<p>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全性。</p>
<h2><a class="anchor" aria-hidden="true" id="拦截器"></a><a href="#拦截器" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拦截器</h2>
<p>Mybatis拦截器设计的初衷就是为了供用户在某些时候可以实现自己的逻辑而不必去动Mybatis固有的逻辑。通过Mybatis拦截器我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑，也可以在执行这些被拦截的方法时执行自己的逻辑而不再执行被拦截的方法。所以Mybatis拦截器的使用范围是非常广泛的。</p>
<h3><a class="anchor" aria-hidden="true" id="mybatis核心对象"></a><a href="#mybatis核心对象" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Mybatis核心对象</h3>
<table>
<thead>
<tr><th>Mybatis核心对象</th><th>解释</th></tr>
</thead>
<tbody>
<tr><td>SqlSession</td><td>作为MyBatis工作的主要顶层API，表示和数据库交互的会话，完成必要数据库增删改查功能</td></tr>
<tr><td>Executor</td><td>MyBatis执行器，是MyBatis调度的核心，负责SQL语句的生成和查询缓存的维护</td></tr>
<tr><td>StatementHandler</td><td>封装了JDBC Statement操作，负责对JDBC statement的操作，如设置参数、将Statement结果集转换成List集合</td></tr>
<tr><td>ParameterHandler</td><td>负责对用户传递的参数转换成JDBC Statement所需要的参数</td></tr>
<tr><td>ResultSetHandler</td><td>负责将JDBC返回的ResultSet结果集对象转换成List类型的集合</td></tr>
<tr><td>TypeHandler</td><td>负责java数据类型和jdbc数据类型之间的映射和转换</td></tr>
<tr><td>MappedStatement</td><td>MappedStatement维护了一条mapper.xml文件里面select 、update、delete、insert节点的封装</td></tr>
<tr><td>SqlSource</td><td>负责根据用户传递的parameterObject，动态地生成SQL语句，将信息封装到BoundSql对象中，并返回</td></tr>
<tr><td>BoundSql</td><td>表示动态生成的SQL语句以及相应的参数信息</td></tr>
<tr><td>Configuration</td><td>MyBatis所有的配置信息都维持在Configuration对象之中</td></tr>
</tbody>
</table>
<p>Mybatis拦截器并不是每个对象里面的方法都可以被拦截的。Mybatis拦截器只能拦截<code>Executor</code>、<code>ParameterHandler</code>、<code>StatementHandler</code>、<code>ResultSetHandler</code>四个对象里面的方法。</p>
<h3><a class="anchor" aria-hidden="true" id="executor"></a><a href="#executor" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Executor</h3>
<p>Mybatis中所有的Mapper语句的执行都是通过Executor进行的。Executor是Mybatis的核心接口。从其定义的接口方法我们可以看出，对应的增删改语句是通过Executor接口的update方法进行的，查询是通过query方法进行的。<font color=red>需要自定义执行的逻辑的时候对Exceutor进行拦截，比如我们封装的CURD。</font>Executor里面可拦截方法如下所示：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Executor</span> </span>{
    ResultHandler NO_RESULT_HANDLER = <span class="hljs-keyword">null</span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(MappedStatement var1, Object var2)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4, CacheKey var5, BoundSql var6)</span> <span class="hljs-keyword">throws</span> SQLException</span>;

    &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(MappedStatement var1, Object var2, RowBounds var3, ResultHandler var4)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function">List&lt;BatchResult&gt; <span class="hljs-title">flushStatements</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function">CacheKey <span class="hljs-title">createCacheKey</span><span class="hljs-params">(MappedStatement var1, Object var2, RowBounds var3, BoundSql var4)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCached</span><span class="hljs-params">(MappedStatement var1, CacheKey var2)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">clearLocalCache</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">deferLoad</span><span class="hljs-params">(MappedStatement var1, MetaObject var2, String var3, CacheKey var4, Class&lt;?&gt; var5)</span></span>;
    <span class="hljs-function">Transaction <span class="hljs-title">getTransaction</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> var1)</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isClosed</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setExecutorWrapper</span><span class="hljs-params">(Executor var1)</span></span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="parameterhandler"></a><a href="#parameterhandler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ParameterHandler</h3>
<p>ParameterHandler用来设置参数规则，当StatementHandler使用<code>prepare()</code>方法后，接下来就是使用它来设置参数。所以<font color=red><strong>如果有对参数做自定义逻辑处理的时候，可以通过拦截ParameterHandler来实现</strong></font>。ParameterHandler里面可以拦截的方法解释如下：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ParameterHandler</span> </span>{
    <span class="hljs-comment">//设置参数规则的时候调用</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setParameters</span><span class="hljs-params">(PreparedStatement var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="statementhandler"></a><a href="#statementhandler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>StatementHandler</h3>
<p>StatementHandler负责处理Mybatis与JDBC之间Statement的交互。一般只拦截StatementHandler里面的prepare方法。<font color=red>拦截prepare可以获取Connection，然后执行额外的逻辑，比如获取总条数。</font></p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatementHandler</span> </span>{
    <span class="hljs-function">Statement <span class="hljs-title">prepare</span><span class="hljs-params">(Connection var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">parameterize</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">batch</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">update</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">query</span><span class="hljs-params">(Statement var1, ResultHandler var2)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function">BoundSql <span class="hljs-title">getBoundSql</span><span class="hljs-params">()</span></span>;
    <span class="hljs-function">ParameterHandler <span class="hljs-title">getParameterHandler</span><span class="hljs-params">()</span></span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="resultsethandler"></a><a href="#resultsethandler" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>ResultSetHandler</h3>
<p>ResultSetHandler用于对查询到的结果做处理。所以<font color=red><strong>如果你有需求需要对返回结果做特殊处理的情况下可以去拦截ResultSetHandler的处理</strong></font>。ResultSetHandler里面常用拦截方法如下：</p>
<pre><code class="hljs css language-java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ResultSetHandler</span> </span>{
    &lt;E&gt; <span class="hljs-function">List&lt;E&gt; <span class="hljs-title">handleResultSets</span><span class="hljs-params">(Statement var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">handleOutputParameters</span><span class="hljs-params">(CallableStatement var1)</span> <span class="hljs-keyword">throws</span> SQLException</span>;
}
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="拦截器的使用"></a><a href="#拦截器的使用" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>拦截器的使用</h3>
<p>拦截器的定义，继承<code>Interceptor</code>接口，并且添加<code>@Intercepts</code>注解。</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Target</span>({ElementType.TYPE})
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Intercepts {
    Signature[] value();
}
<span class="hljs-meta">@Retention</span>(RetentionPolicy.RUNTIME)
<span class="hljs-meta">@Target</span>({ElementType.TYPE})
<span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Signature {
    Class&lt;?&gt; type();<span class="hljs-comment">//拦截的类型Executor、ParameterHandler、StatementHandler、ResultSetHandler中的一个</span>
    <span class="hljs-function">String <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//在定义拦截类的基础之上，再定义拦截的方法</span>
    Class&lt;?&gt;[] args();<span class="hljs-comment">//方法可能重载，所有定义参数</span>
}

</code></pre>
<p>举例：</p>
<p>拦截Executor中的query和update方法。</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Intercepts</span>({
        <span class="hljs-meta">@Signature</span>(type = Executor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">method</span> </span>= <span class="hljs-string">"query"</span>, args = {MappedStatement<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Object</span>.<span class="hljs-title">class</span>, <span class="hljs-title">RowBounds</span>.<span class="hljs-title">class</span>, <span class="hljs-title">ResultHandler</span>.<span class="hljs-title">class</span>}),
        @<span class="hljs-title">Signature</span>(<span class="hljs-title">type</span> </span>= Executor<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">method</span> </span>= <span class="hljs-string">"update"</span>, args = {MappedStatement<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">Object</span>.<span class="hljs-title">class</span>})
})
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">CrudInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
        <span class="hljs-comment">//....</span>
    }
}
</code></pre>
<p>拦截StatementHandler里面的prepare方法。</p>
<pre><code class="hljs css language-java"><span class="hljs-meta">@Intercepts</span>( { <span class="hljs-meta">@Signature</span>(method = <span class="hljs-string">"prepare"</span>, type = StatementHandler<span class="hljs-class">.<span class="hljs-keyword">class</span>, <span class="hljs-title">args</span> </span>= {Connection<span class="hljs-class">.<span class="hljs-keyword">class</span>}) })
<span class="hljs-title">public</span> <span class="hljs-title">class</span> <span class="hljs-title">PrepareInterceptor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseInterceptor</span> </span>{
    <span class="hljs-meta">@Override</span>
    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>{
    }
}
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="缓存"></a><a href="#缓存" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>缓存</h2>
<h3><a class="anchor" aria-hidden="true" id="一级缓存"></a><a href="#一级缓存" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>一级缓存</h3>
<p>Mybatis对缓存提供支持，<strong>但是在没有配置的默认情况下，它只开启一级缓存</strong>。一级缓存只是相对于同一个SqlSession而言。所以在参数和SQL完全一样的情况下，我们使用同一个SqlSession对象调用一个Mapper方法，往往只执行一次SQL，因为使用SqlSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p>
<p><strong>1、一级缓存的生命周期有多长？</strong></p>
<p>a、MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉</p>
<p>b、如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用</p>
<p>c、如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用</p>
<p>d、SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用</p>
<p><strong>2、怎么判断某两次查询是完全相同的查询？</strong>MyBatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。通俗的理解就是sql一致，参数一致。</p>
<p>a、传入的statementId</p>
<p>b、查询时要求的结果集中的结果范围</p>
<p>c、这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）</p>
<p>d、传递给java.sql.Statement要设置的参数值</p>
<p><strong>清除一级缓存</strong>：</p>
<pre><code class="hljs css language-java">SqlSessionUtils.getSqlSession(SpringContextHolder.getBean(SqlSessionFactory<span class="hljs-class">.<span class="hljs-keyword">class</span>)).<span class="hljs-title">clearCache</span>()</span>;
</code></pre>
<h3><a class="anchor" aria-hidden="true" id="二级缓存"></a><a href="#二级缓存" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>二级缓存</h3>
<p>二级缓存是Mapper级别的，Mybatis默认是没有开启二级缓存的。二级缓存是Application级别的，它的作用域是同一个namespace下的Mapper映射文件内容，多个SqlSession共享。Mybatis需要手动设置启动二级缓存。</p>
<p>二级缓存是默认启用的（要生效需要对每个Mapper进行配置），如想取消，则可以通过Mybatis配置文件中的元素下的子元素来指定cacheEnabled为false。</p>
<pre><code class="hljs css language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span>
  <span class="hljs-comment">&lt;!-- 默认是true，需要和Mapper里面的cache配置使用才能开启二级缓存 --&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"cacheEnabled"</span> <span class="hljs-attr">value</span>=<span class="hljs-string">"true"</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span>
</code></pre>
<p>如果需要开启某个Mapper的二级缓存需要在Mapper中显式定义cache，如下：</p>
<pre><code class="hljs css language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">"..."</span>&gt;</span>
    <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">eviction</span>=<span class="hljs-string">"LRU"</span> <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">"100000"</span> <span class="hljs-attr">readOnly</span>=<span class="hljs-string">"true"</span> <span class="hljs-attr">size</span>=<span class="hljs-string">"1024"</span>/&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span>
</code></pre>
<p><strong>eviction</strong>：驱逐，代表的是缓存回收策略，目前MyBatis提供以下策略：</p>
<ul>
<li>LRU，最近最少使用的，移除最长时间不用的对象</li>
<li>FIFO，先进先出，按对象进入缓存的顺序来移除他们</li>
<li>SOFT，软引用，移除基于垃圾回收器状态和软引用规则的对象</li>
<li>WEAK，弱引用，更积极的移除基于垃圾收集器状态和弱引用规则的对象</li>
</ul>
<p><strong>flushInterval</strong>：刷新间隔时间，单位为毫秒，这里配置的是100秒刷新；如果不配置它，那么当SQL被执行的时候才会去刷新缓存</p>
<p><strong>size</strong>：引用数目，一个正整数，代表缓存最多可以存储多少个对象，不宜设置过大，设置过大会导致内存溢出</p>
<p><strong>readOnly</strong>：只读，意味着缓存数据只能读取而不能修改，这样设置的好处是我们可以快速读取缓存，缺点是我们没有办法修改缓存，他的默认值是false，不允许我们修改</p>
<p><strong>type</strong>：用来指定当前底层缓存实现类，默认是PerpetualCache，如果我们想使用自定义的Cache，则可以通过该属性来指定，对应的值是我们自定义的Cache的全路径名称。</p>
<p><strong>userCache，fulshCache都是配置二级缓存的。</strong></p>
<h2><a class="anchor" aria-hidden="true" id="延迟加载"></a><a href="#延迟加载" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>延迟加载</h2>
<p>延迟加载其实就是将数据加载时机推迟，比如推迟嵌套查询的执行时机。在Mybatis中经常用到关联查询，但是并不是任何时候都需要立即返回关联查询结果。比如查询订单信息，并不一定需要及时返回订单对应的产品信息，查询商品分类信息并不一定要及时返回该类别下有哪些产品，这种情况一下需要一种机制，当需要查看时，再执行查询，返回需要的结果集，这种需求在Mybatis中可以使用延迟加载机制来实现。延迟加载可以实现先查询主表，按需实时做关联查询，返回关联表结果集，一定程度上提高了效率。</p>
<p>它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成a.getB().getName()方法的调用。这就是延迟加载的基本原理。当然了，不光是Mybatis，几乎所有的包括Hibernate，支持延迟加载的原理都是一样的。</p>
<h2><a class="anchor" aria-hidden="true" id="mybatis一对一一对多"></a><a href="#mybatis一对一一对多" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MyBatis一对一一对多</h2>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#和的区别是什么"><code>#{}</code>和<code>${}</code>的区别是什么</a></li><li><a href="#拦截器">拦截器</a><ul class="toc-headings"><li><a href="#mybatis核心对象">Mybatis核心对象</a></li><li><a href="#executor">Executor</a></li><li><a href="#parameterhandler">ParameterHandler</a></li><li><a href="#statementhandler">StatementHandler</a></li><li><a href="#resultsethandler">ResultSetHandler</a></li><li><a href="#拦截器的使用">拦截器的使用</a></li></ul></li><li><a href="#缓存">缓存</a><ul class="toc-headings"><li><a href="#一级缓存">一级缓存</a></li><li><a href="#二级缓存">二级缓存</a></li></ul></li><li><a href="#延迟加载">延迟加载</a></li><li><a href="#mybatis一对一一对多">MyBatis一对一一对多</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2020</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'my-search-only-api-key-1234',
                indexName: 'my-index-name',
                inputSelector: '#search_input_react'
              });
            </script></body></html>