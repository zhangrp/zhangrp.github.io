<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>服务无状态化设计 · 博客</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="## 服务无状态化定义"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="服务无状态化设计 · 博客"/><meta property="og:type" content="website"/><meta property="og:url" content="https://your-docusaurus-test-site.com/"/><meta property="og:description" content="## 服务无状态化定义"/><meta name="twitter:card" content="summary"/><link rel="shortcut icon" href="/img/favicon.ico"/><link rel="stylesheet" href="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.css"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><link rel="alternate" type="application/atom+xml" href="https://your-docusaurus-test-site.com/blog/atom.xml" title="博客 Blog ATOM Feed"/><link rel="alternate" type="application/rss+xml" href="https://your-docusaurus-test-site.com/blog/feed.xml" title="博客 Blog RSS Feed"/><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script src="/js/scrollSpy.js"></script><link rel="stylesheet" href="/css/main.css"/><script src="/js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href="/"><img class="logo" src="/img/favicon.ico" alt="博客"/><h2 class="headerTitleWithLogo">博客</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class=""><a href="/docs/directory" target="_self">Docs</a></li><li class=""><a href="/blog/" target="_self">Blog</a></li><li class="navSearchWrapper reactNavSearchWrapper"><input type="text" id="search_input_react" placeholder="Search" title="Search"/></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="container mainContainer docsContainer"><div class="wrapper"><div class="post"><header class="postHeader"><h1 id="__docusaurus" class="postHeaderTitle">服务无状态化设计</h1></header><article><div><span><h2><a class="anchor" aria-hidden="true" id="服务无状态化定义"></a><a href="#服务无状态化定义" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务无状态化定义</h2>
<p>同一服务（进程）冗余部署N份，N份完全对等，请求提交到任何一份冗余服务上，处理结果完全一样。另外，进程内有无数据并不是无状态判断的标准（要看放的是什么数据，是否是对等的数据，比如电商商品分类信息就是完全对等的）。</p>
<h2><a class="anchor" aria-hidden="true" id="服务无状态化目的"></a><a href="#服务无状态化目的" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务无状态化目的</h2>
<ul>
<li>快速扩容服务</li>
<li>弹性缩容服务：当服务挂了之后，进行服务缩容</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="服务无状态化案例"></a><a href="#服务无状态化案例" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>服务无状态化案例</h2>
<p>一般是网关层做无状态化设计。</p>
<p>session，JWT，基于token机制的：token本身带用户信息（JWT），token无含义+redis</p>
<p>如何把有状态的服务变成无状态的：把有状态的数据从服务中剥离出来。</p>
<h3><a class="anchor" aria-hidden="true" id="session-sticky会话粘滞"></a><a href="#session-sticky会话粘滞" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Session Sticky会话粘滞</h3>
<p>该方案的核心是让同一Session的请求每次都发送到同一个服务器端处理，非常有利于针<font color=red>对Session进行服务器端本地缓存</font>的应用。</p>
<p>存在问题：</p>
<p>1、如果有一台Web服务器宕机或重启，这台机器上的会话数据会丢失，涉及到的用户需要重新登录（Session数据可进程外本机存储，这样数据不会丢失，如果服务能立刻重启，影响时间小，但如果这一段时间用户重新登录，请求到其它主机，会发生数据漂移的情况。）</p>
<p>2、会话标示是应用层信息，负载均衡器需要解析应用层，也就是要7层负载，比4层负载消耗大（该点可以变通解决，通过iphash的方式，同一客户端的ip的每次请求都会请求到同一服务器端处理，而不是按照SessionI进行hash）</p>
<h3><a class="anchor" aria-hidden="true" id="session-replication会话复制"></a><a href="#session-replication会话复制" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Session Replication会话复制</h3>
<p><img src="./chapter2-2-stateless.assets/image13.png" style="zoom:50%;" /></p>
<p>一般的应用容器都支持Session Replication方式，且对负载均衡器没有那么多的要求。</p>
<p>1、Session数据同步网络带宽消耗大</p>
<p>2、每台机器上都有全量的Session数据，仅适合少数几台机器。</p>
<h3><a class="anchor" aria-hidden="true" id="session集中存储"></a><a href="#session集中存储" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Session集中存储</h3>
<p>采用Redis集中存储Session。</p>
<p>问题：读取操作Sesion引入了网络操作，存在时延和不稳定性，不过一般基本在内网，问题不大（通过Jedis连接池，获取并更新过期时间，控制在毫秒级别）；另外集中存储如果出现问题，将影响应用。</p>
<h3><a class="anchor" aria-hidden="true" id="cookie-based"></a><a href="#cookie-based" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Cookie Based</h3>
<p>通过Cookie来传递Session数据。不存在Session集中存储中从外部系统获取、写入Session数据的网络时延、不稳定性。</p>
<p><img src="./chapter2-2-stateless.assets/image14.png" style="zoom:50%;" /></p>
<p>1、Cookie长度的限制</p>
<p>2、安全性。对Cookie中的Session数据进行加密</p>
<p>4、带宽消耗：不是内网间的带宽消耗，而是外围到内网的带宽消耗</p>
<h3><a class="anchor" aria-hidden="true" id="jwt"></a><a href="#jwt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JWT</h3>
<h4><a class="anchor" aria-hidden="true" id="什么是jwt"></a><a href="#什么是jwt" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>什么是JWT</h4>
<p>Json web token (JWT),是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（RFC
7519）。该token被设计为紧凑且安全的，特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息，以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。</p>
<h4><a class="anchor" aria-hidden="true" id="传统的session认证"></a><a href="#传统的session认证" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>传统的session认证</h4>
<p>http协议本身是一种无状态的协议，这就意味着如果用户向应用提供了用户名和密码来进行用户认证，那么下一次请求时，用户还要再一次进行用户认证才行，因为根据http协议，我们并不能知道是哪个用户发出的请求。所以为了让我们的应用能识别是哪个用户发出的请求，我们只能在<strong>服务器存储一份用户登录的信息，这个就是session</strong>，并且在响应时把该session对应的ID，sessionId传递给浏览器，告诉其保存为cookie，以便下次请求时在cooke中带上该sessionId，这样我们的应用就能识别请求来自哪个用户了，这就是传统的基于session认证。</p>
<p>这种基于session的认证使应用本身很难得到扩展，随着不同客户端用户的增加，独立的服务器已无法承载更多的用户，而这时候基于session认证应用的问题就会暴露出来。（session是存在服务端的）</p>
<h4><a class="anchor" aria-hidden="true" id="基于session认证所显露的问题"></a><a href="#基于session认证所显露的问题" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于session认证所显露的问题</h4>
<p>Session: 每个用户经过我们的应用认证之后，我们的应用都要在服务端做一次记录，以方便用户下次请求的鉴别，通常而言session都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大。</p>
<p>扩展性: 用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</p>
<p>CSRF: 因为是基于cookie来进行用户识别的，cookie如果被截获，用户就会很容易受到跨站请求伪造的攻击。</p>
<h4><a class="anchor" aria-hidden="true" id="基于tokenredis的鉴权机制"></a><a href="#基于tokenredis的鉴权机制" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>基于token+redis的鉴权机制</h4>
<p>为了解决扩展性问题，慢慢发展出通过token+redis的鉴权机制。流程上是这样的：</p>
<blockquote>
<p>①用户使用用户名密码来请求服务<br>
②服务器验证用户的信息<br>
③服务器验证通过后发送给用户一个token，并把token对应的用户信息存储在redis中<br>
④客户端存储token，并在每次请求时附送上这个token值<br>
⑤服务端验证token值，并返回数据</p>
</blockquote>
<p>这个token必须要在每次请求时传递给服务端，它应该保存在请求头里，另外，服务端要支持CORS（跨来源资源共享）策略，一般我们在服务端这么做就可以了<code>Access-Control-Allow-Origin: *</code>。</p>
<p>这个token中不含义语义，每次需要去redis中获取信息，慢慢演化成去掉redis在token中包含用户信息语义。这就是JWT。</p>
<h4><a class="anchor" aria-hidden="true" id="jwt鉴权机制"></a><a href="#jwt鉴权机制" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>JWT鉴权机制</h4>
<p>JWT是由三段信息构成的，分别为头部（header）、荷载（payload）、签证（signature），通过&quot;.&quot;连接起来。类似下面的样子：</p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></p>
<p><strong>头部header</strong>包含两部分信息，类型（这里就是jwt）和加密算法（通常直接使用HMAC SHA256）。完整的头部就像下面这样的JSON：<code>{'typ': 'JWT', 'alg': 'HS256'}</code>，然后将头部进行base64加密。</p>
<p><strong>载荷playload</strong>就是存放有效信息的地方，包含三个部分：标准中注册的声明、公共的声明、私有的声明</p>
<p>标准中注册的声明 (建议但不强制使用) ，JWT指定七个默认字段供选择：</p>
<blockquote>
<p>iss：jwt签发者<br>
sub：jwt所面向的用户<br>
aud：接收jwt的一方<br>
exp：jwt的过期时间，这个过期时间必须要大于签发时间<br>
nbf：定义在什么时间之前，该jwt都是不可用的<br>
iat：jwt的签发时间<br>
jti：jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击</p>
</blockquote>
<p>公共的声明：可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息。但不建议添加敏感信息，因为该部分在客户端可解密。</p>
<p>私有的声明：是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。</p>
<p>如，定义一个payload：<code>{&quot;sub&quot;: &quot;1234567890&quot;,&quot;name&quot;: &quot;John Doe&quot;,&quot;admin&quot;: true}</code>，然后将其进行base64加密，得到Jwt的第二部分：<code>eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9</code></p>
<p><strong>签证signature</strong>，签证信息由三部分组成：<strong>header
(base64后的)</strong>，<strong>payload (base64后的)</strong>，**secret</p>
<p>这个部分需要base64加密后的header和base64加密后的payload使用&quot;.&quot;连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> encodedString = base64UrlEncode(header) + <span class="hljs-string">'.'</span> + base64UrlEncode(payload);

<span class="hljs-keyword">var</span> signature = HMACSHA256(encodedString, <span class="hljs-string">'secret'</span>); <span class="hljs-comment">//TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</span>
</code></pre>
<p>将这三部分用&quot;.&quot;连接成一个完整的字符串，构成了最终的jwt：</p>
<p><code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ</code></p>
<p>注意：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证，所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret,那就意味着客户端是可以自我签发jwt了。</p>
<p><font color=red>其实JWT可以简化设计：DES（userId+ttl+salt）。那么过期策略应该怎么弄？客户端的token应该怎么设计？</p>
<p>1、用户第一次用户名密码登录，成功后生成token，过期时间设置成1天</p>
<p>2、后面用户每次请求都带上这个token，进行校验</p>
<p>3、用户每次打开APP时，请求校验token，如果token是一个月前的，提示用户重新登录，否者刷新token，设置过期时间1天，然后返回新的token</p>
<p>存在问题：用户换手机，旧手机仍然可以登录。多终端登录的问题。所以服务端必须要存储token。</font></p>
<p><strong>JWT缺点</strong></p>
<p>1、jwt太长。由于是无状态使用JWT，所有的数据都被放到JWT里，如果还要进行一些数据交换，那载荷会更大，经过编码之后导致jwt非常长，cookie的限制大小一般是4k，cookie很可能放不下，所以jwt一般放在local storage里面。并且用户在系统中的每一次http请求都会把jwt携带在Header里面，http请求的Header可能比Body还要大。而sessionId只是很短的一个字符串，因此使用jwt的http请求比使用session的开销大得多。</p>
<p>2、一次性。无状态是JWT的特点，也导致了它是一次性的，无法废弃和续签。</p>
<ul>
<li><p>无法废弃：和在服务端进行黑名单校验，一旦签发了新的JWT，那么旧的就加入到黑名单，避免再次使用</p></li>
<li><p>续签：如果要实现过期时间为30分钟，最简单的办法就是每次请求时都刷新jwt，大这种方式每次都要做jwt的加密解密，会带来性能问题。另一种方式就是废弃jwt中的ttl，而放在redis中，每次访问时刷新redis中的过期时间。</p></li>
</ul>
<p>可以看出要破解jwt的一次性特点，就必须要服务端存储jwt，这样jwt就又变成有状态的了，违背了jwt的设计初衷。</p>
<p><strong>JWT的适用场景</strong></p>
<p>适用JWT的场景：有效期短、只希望被使用一次。比如用户注册成功后邮件发送的激活链接。该链接的特点：能够标识用户、该链接具有时效性、不能被篡改。</p>
<p>由于JWT的一次性特点，单点登录和会话管理不适合用jwt，如果在服务端部署额外的存储逻辑存储jwt状态，那不如使用session。</p>
</span></div></article></div><div class="docs-prevnext"></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#服务无状态化定义">服务无状态化定义</a></li><li><a href="#服务无状态化目的">服务无状态化目的</a></li><li><a href="#服务无状态化案例">服务无状态化案例</a><ul class="toc-headings"><li><a href="#session-sticky会话粘滞">Session Sticky会话粘滞</a></li><li><a href="#session-replication会话复制">Session Replication会话复制</a></li><li><a href="#session集中存储">Session集中存储</a></li><li><a href="#cookie-based">Cookie Based</a></li><li><a href="#jwt">JWT</a></li></ul></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="copyright">Copyright © 2020</section></footer></div><script type="text/javascript" src="https://cdn.jsdelivr.net/docsearch.js/1/docsearch.min.js"></script><script>
                document.addEventListener('keyup', function(e) {
                  if (e.target !== document.body) {
                    return;
                  }
                  // keyCode for '/' (slash)
                  if (e.keyCode === 191) {
                    const search = document.getElementById('search_input_react');
                    search && search.focus();
                  }
                });
              </script><script>
              var search = docsearch({
                
                apiKey: 'my-search-only-api-key-1234',
                indexName: 'my-index-name',
                inputSelector: '#search_input_react'
              });
            </script></body></html>